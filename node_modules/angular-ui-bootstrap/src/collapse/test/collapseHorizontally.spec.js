describe("collapse directive",function(){function initCallbacks(){scope.collapsing=jasmine.createSpy("scope.collapsing"),scope.collapsed=jasmine.createSpy("scope.collapsed"),scope.expanding=jasmine.createSpy("scope.expanding"),scope.expanded=jasmine.createSpy("scope.expanded")}function assertCallbacks(expected){["collapsing","collapsed","expanding","expanded"].forEach(function(cbName){expected[cbName]?expect(scope[cbName]).toHaveBeenCalled():expect(scope[cbName]).not.toHaveBeenCalled()})}var elementH,compileFnH,scope,$compile,$animate,$q;beforeEach(module("ui.bootstrap.collapse")),beforeEach(module("ngAnimateMock")),beforeEach(inject(function(_$rootScope_,_$compile_,_$animate_,_$q_){scope=_$rootScope_,$compile=_$compile_,$animate=_$animate_,$q=_$q_})),beforeEach(function(){elementH=angular.element('<div uib-collapse="isCollapsed" expanding="expanding()" expanded="expanded()" collapsing="collapsing()" collapsed="collapsed()" horizontal>Some Content</div>'),compileFnH=$compile(elementH),angular.element(document.body).append(elementH)}),afterEach(function(){elementH.remove()}),it("should be hidden on initialization if isCollapsed = true",function(){initCallbacks(),scope.isCollapsed=!0,compileFnH(scope),scope.$digest(),expect(elementH.width()).toBe(0),assertCallbacks({collapsed:!0})}),it("should not trigger any animation on initialization if isCollapsed = true",function(){var wrapperFn=function(){$animate.flush()};scope.isCollapsed=!0,compileFnH(scope),scope.$digest(),expect(wrapperFn).toThrowError(/No pending animations ready to be closed or flushed/)}),it("should collapse if isCollapsed = true on subsequent use",function(){scope.isCollapsed=!1,compileFnH(scope),scope.$digest(),initCallbacks(),scope.isCollapsed=!0,scope.$digest(),$animate.flush(),expect(elementH.width()).toBe(0),assertCallbacks({collapsing:!0,collapsed:!0})}),it("should show after toggled from collapsed",function(){initCallbacks(),scope.isCollapsed=!0,compileFnH(scope),scope.$digest(),expect(elementH.width()).toBe(0),assertCallbacks({collapsed:!0}),scope.collapsed.calls.reset(),scope.isCollapsed=!1,scope.$digest(),$animate.flush(),expect(elementH.width()).not.toBe(0),assertCallbacks({expanding:!0,expanded:!0})}),it("should not trigger any animation on initialization if isCollapsed = false",function(){var wrapperFn=function(){$animate.flush()};scope.isCollapsed=!1,compileFnH(scope),scope.$digest(),expect(wrapperFn).toThrowError(/No pending animations ready to be closed or flushed/)}),it("should expand if isCollapsed = false on subsequent use",function(){scope.isCollapsed=!1,compileFnH(scope),scope.$digest(),scope.isCollapsed=!0,scope.$digest(),$animate.flush(),initCallbacks(),scope.isCollapsed=!1,scope.$digest(),$animate.flush(),expect(elementH.width()).not.toBe(0),assertCallbacks({expanding:!0,expanded:!0})}),it("should collapse if isCollapsed = true on subsequent uses",function(){scope.isCollapsed=!1,compileFnH(scope),scope.$digest(),scope.isCollapsed=!0,scope.$digest(),$animate.flush(),scope.isCollapsed=!1,scope.$digest(),$animate.flush(),initCallbacks(),scope.isCollapsed=!0,scope.$digest(),$animate.flush(),expect(elementH.width()).toBe(0),assertCallbacks({collapsing:!0,collapsed:!0})}),it("should change aria-expanded attribute",function(){scope.isCollapsed=!1,compileFnH(scope),scope.$digest(),expect(elementH.attr("aria-expanded")).toBe("true"),scope.isCollapsed=!0,scope.$digest(),$animate.flush(),expect(elementH.attr("aria-expanded")).toBe("false")}),it("should change aria-hidden attribute",function(){scope.isCollapsed=!1,compileFnH(scope),scope.$digest(),expect(elementH.attr("aria-hidden")).toBe("false"),scope.isCollapsed=!0,scope.$digest(),$animate.flush(),expect(elementH.attr("aria-hidden")).toBe("true")}),describe("expanding callback returning a promise",function(){var defer,collapsedWidth;beforeEach(function(){defer=$q.defer(),scope.isCollapsed=!0,scope.expanding=function(){return defer.promise},compileFnH(scope),scope.$digest(),collapsedWidth=elementH.width(),scope.isCollapsed=!1,scope.$digest(),expect(elementH.attr("aria-expanded")).not.toBe("true"),expect(elementH.width()).toBe(collapsedWidth)}),it("should wait for it to resolve before animating",function(){defer.resolve(),scope.$digest(),$animate.flush(),expect(elementH.attr("aria-expanded")).toBe("true"),expect(elementH.width()).toBeGreaterThan(collapsedWidth)}),it("should not animate if it rejects",function(){defer.reject(),scope.$digest(),expect(elementH.attr("aria-expanded")).not.toBe("true"),expect(elementH.width()).toBe(collapsedWidth)})}),describe("collapsing callback returning a promise",function(){var defer,expandedWidth;beforeEach(function(){defer=$q.defer(),scope.isCollapsed=!1,scope.collapsing=function(){return defer.promise},compileFnH(scope),scope.$digest(),expandedWidth=elementH.width(),scope.isCollapsed=!0,scope.$digest(),expect(elementH.attr("aria-expanded")).not.toBe("false"),expect(elementH.width()).toBe(expandedWidth)}),it("should wait for it to resolve before animating",function(){defer.resolve(),scope.$digest(),$animate.flush(),expect(elementH.attr("aria-expanded")).toBe("false"),expect(elementH.width()).toBeLessThan(expandedWidth)}),it("should not animate if it rejects",function(){defer.reject(),scope.$digest(),expect(elementH.attr("aria-expanded")).not.toBe("false"),expect(elementH.width()).toBe(expandedWidth)})})});