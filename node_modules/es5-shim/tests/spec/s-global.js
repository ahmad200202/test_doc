describe("global methods",function(){"use strict";var foo=function(){},functionsHaveNames="foo"===foo.name,ifFunctionsHaveNamesIt=functionsHaveNames?it:xit,hasSymbols="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator,ifSymbolsIt=hasSymbols?it:xit,is=function(x,y){return 0===x&&0===y?1/x===1/y:x===y};describe("parseInt",function(){ifFunctionsHaveNamesIt("has the right name",function(){expect(parseInt.name).toBe("parseInt")}),it("accepts a radix",function(){for(var i=2;36>=i;++i)expect(parseInt("10",i)).toBe(i)}),it("defaults the radix to 10 when the number does not start with 0x or 0X",function(){["01","08","10","42"].forEach(function(str){expect(parseInt(str)).toBe(parseInt(str,10))})}),it("defaults the radix to 16 when the number starts with 0x or 0X",function(){expect(parseInt("0x16")).toBe(parseInt("0x16",16)),expect(parseInt("0X16")).toBe(parseInt("0X16",16))}),it("ignores leading whitespace",function(){expect(parseInt("  0x16")).toBe(parseInt("0x16",16)),expect(parseInt("  42")).toBe(parseInt("42",10)),expect(parseInt("  08")).toBe(parseInt("08",10));var ws="	\n\f\r   ᠎             　\u2028\u2029﻿";expect(parseInt(ws+"08")).toBe(parseInt("08",10)),expect(parseInt(ws+"0x16")).toBe(parseInt("0x16",16))}),it("defaults the radix properly when not a true number",function(){var fakeZero={valueOf:function(){return 0}};expect(parseInt("08",fakeZero)).toBe(parseInt("08",10)),expect(parseInt("0x16",fakeZero)).toBe(parseInt("0x16",16))}),it("allows sign-prefixed hex values",function(){expect(parseInt("-0xF")).toBe(-15),expect(parseInt("-0xF",16)).toBe(-15),expect(parseInt("+0xF")).toBe(15),expect(parseInt("+0xF",16)).toBe(15)}),it("NaN parsing",function(){expect(parseInt()).toBeNaN(),expect(parseInt(void 0)).toBeNaN(),expect(parseInt(null)).toBeNaN(),expect(parseInt(0/0)).toBeNaN()}),ifSymbolsIt("throws on symbols",function(){expect(function(){parseInt(Symbol(""))}).toThrow(),expect(function(){parseInt(Object(Symbol("")))}).toThrow()})}),describe("parseFloat()",function(){it("works with zeroes",function(){expect(is(parseFloat("0"),0)?"+0":"-0").toBe("+0"),expect(is(parseFloat(" 0"),0)?"+0":"-0").toBe("+0"),expect(is(parseFloat("+0"),0)?"+0":"-0").toBe("+0"),expect(is(parseFloat(" +0"),0)?"+0":"-0").toBe("+0"),expect(is(parseFloat("-0"),-0)?"-0":"+0").toBe("-0"),expect(is(parseFloat(" -0"),-0)?"-0":"+0").toBe("-0")}),it("NaN parsing",function(){expect(parseFloat(void 0)).toBeNaN(),expect(parseFloat(null)).toBeNaN(),expect(parseFloat(0/0)).toBeNaN()})})});